{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/polyfills.ts", "../library/src/utils/paths.ts", "../library/src/engine/signals.ts", "../library/src/utils/dom.ts", "../library/src/utils/text.ts", "../library/src/engine/engine.ts"],
  "sourcesContent": ["const lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\nexport const DATASTAR_FETCH_EVENT = 'datastar-fetch'\nexport const DATASTAR_SIGNAL_PATCH_EVENT = 'datastar-signal-patch'\n", "export const hasOwn: (obj: object, prop: PropertyKey) => boolean =\n  // @ts-expect-error\n  Object.hasOwn ?? Object.prototype.hasOwnProperty.call\n", "import type { Paths } from '@engine/types'\nimport { hasOwn } from '@utils/polyfills'\n\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport const isEmpty = (obj: Record<string, any>): boolean => {\n  for (const prop in obj) {\n    if (hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport const updateLeaves = (\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) => {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (paths: Paths): Record<string, any> => {\n  const result: Record<string, any> = {}\n  for (const [path, value] of paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), result)\n    obj[lastKey] = value\n  }\n  return result\n}\n", "import { DATASTAR_SIGNAL_PATCH_EVENT } from '@engine/consts'\nimport type {\n  Computed,\n  Effect,\n  JSONPatch,\n  MergePatchArgs,\n  Paths,\n  Signal,\n  SignalFilterOptions,\n} from '@engine/types'\nimport { isPojo, pathToObj } from '@utils/paths'\nimport { hasOwn } from '@utils/polyfills'\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  version_: number\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = unknown> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = unknown> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nconst currentPatch: Paths = []\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet prevSub: ReactiveNode | undefined\nlet activeSub: ReactiveNode | undefined\nlet version = 0\n\nexport const beginBatch = (): void => {\n  batchDepth++\n}\n\nexport const endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nexport const startPeeking = (sub?: ReactiveNode): void => {\n  prevSub = activeSub\n  activeSub = sub\n}\n\nexport const stopPeeking = (): void => {\n  activeSub = prevSub\n  prevSub = undefined\n}\n\nexport const signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nexport const computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-expect-error\n  c[computedSymbol] = 1\n  return c\n}\n\nexport const effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  startPeeking(e)\n  beginBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    stopPeeking()\n  }\n  return effectOper.bind(0, e)\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  startPeeking(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    stopPeeking()\n    endTracking(c)\n  }\n}\n\nconst updateSignal = <T>(s: AlienSignal<T>, value: T): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    startPeeking(e)\n    startTracking(e)\n    beginBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      stopPeeking()\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    if (s.value_ !== (s.value_ = value[0])) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  const nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n  if (nextDep && nextDep.dep_ === dep) {\n    nextDep.version_ = version\n    sub.depsTail_ = nextDep\n    return\n  }\n  const prevSub = dep.subsTail_\n  if (prevSub && prevSub.version_ === version && prevSub.sub_ === sub) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        version_: version,\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (\n      !(\n        flags &\n        (60 as\n          | ReactiveFlags.RecursedCheck\n          | ReactiveFlags.Recursed\n          | ReactiveFlags.Dirty\n          | ReactiveFlags.Pending)\n      )\n    ) {\n      sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n    } else if (\n      !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n    ) {\n      flags = 0 satisfies ReactiveFlags.None\n    } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n      sub.flags_ =\n        (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n        (32 satisfies ReactiveFlags.Pending)\n    } else if (\n      !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n      isValidLink(link, sub)\n    ) {\n      sub.flags_ =\n        flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n      flags &= 1 satisfies ReactiveFlags.Mutable\n    } else {\n      flags = 0 satisfies ReactiveFlags.None\n    }\n\n    if (flags & (2 satisfies ReactiveFlags.Watching)) {\n      notify(sub as AlienEffect)\n    }\n\n    if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n      const subSubs = sub.subs_\n      if (subSubs) {\n        const nextSub = (link = subSubs).nextSub_\n        if (nextSub) {\n          stack = { value_: next, prev_: stack }\n          next = nextSub\n        }\n        continue\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  version++\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n  let dirty = false\n\n  top: while (true) {\n    const dep = link.dep_\n    const flags = dep.flags_\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (flags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (flags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty) {\n      const nextDep = link.nextDep_\n      if (nextDep) {\n        link = nextDep\n        continue\n      }\n    }\n\n    while (checkDepth--) {\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n        dirty = false\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const flags = sub.flags_\n    if (\n      (flags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = flags | (16 satisfies ReactiveFlags.Dirty)\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n  } while ((link = link.nextSub_!))\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  let link = sub.depsTail_\n  while (link) {\n    if (link === checkLink) {\n      return true\n    }\n    link = link.prevDep_\n  }\n  return false\n}\n\nexport const getPath = <T = any>(path: string): T | undefined => {\n  let result = root\n  const split = path.split('.')\n  for (const path of split) {\n    if (result == null || !hasOwn(result, path)) {\n      return\n    }\n    result = result[path]\n  }\n  return result as T\n}\n\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal<any>>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal<any>>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get(_, prop: string) {\n        // JSON.stringify calls `.toJSON()` directly instead of checking if it exists on the object\n        // so we have to check if `toJSON` is being called and prevent a signal from automatically\n        // being made so JSON.stringify can fallback to the default stringify\n        if (!(prop === 'toJSON' && !hasOwn(deepObj, prop))) {\n          // special case for when prop is an array function because every array function needs to\n          // be reactive to when the keys change\n          if (isArr && prop in Array.prototype) {\n            keys()\n            return deepObj[prop]\n          }\n          // if prop is a symbol just return the symbol because we don't want to make up that theres\n          // an iterator symbol on an object or not\n          if (typeof prop === 'symbol') {\n            return deepObj[prop]\n          }\n          // if obj doesnt have prop OR prop is null or undefined then create a signal and default\n          // to an empty string\n          if (!hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n            deepObj[prop] = signal('')\n            dispatch(prefix + prop, '')\n            keys(keys() + 1)\n          }\n          return deepObj[prop]()\n        }\n      },\n      set(_, prop: string, newValue) {\n        const path = prefix + prop\n        // special case for when setting length so we can make a diff patch\n        if (isArr && prop === 'length') {\n          const diff = (deepObj[prop] as unknown as number) - newValue\n          deepObj[prop] = newValue\n          // manually make a diff patch for now, shouldnt have to do this when object diffing is\n          // implemented. see https://github.com/starfederation/datastar-dev/issues/274\n          if (diff > 0) {\n            const patch: Record<string, any> = {}\n            for (let i = newValue; i < deepObj[prop]; i++) {\n              patch[i] = null\n            }\n            dispatch(prefix.slice(0, -1), patch)\n            keys(keys() + 1)\n          }\n        } else if (hasOwn(deepObj, prop)) {\n          if (newValue == null) {\n            delete deepObj[prop]\n            // if newValue is a computed set the computed directly instead of wrapping in signal\n          } else if (hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch(path, '')\n            // if prop changed after setting it then dispatch\n          } else {\n            const currentValue = deepObj[prop]()\n            const pathStr = `${path}.`\n            if (isPojo(currentValue) && isPojo(newValue)) {\n              for (const key in currentValue) {\n                if (!hasOwn(newValue, key)) {\n                  delete currentValue[key]\n                  dispatch(pathStr + key, null)\n                }\n              }\n              for (const key in newValue) {\n                const nextVal = newValue[key]\n                if (currentValue[key] !== nextVal) {\n                  currentValue[key] = nextVal\n                }\n              }\n            } else if (deepObj[prop](deep(newValue, pathStr))) {\n              dispatch(path, newValue)\n            }\n          }\n          // if newValue is null or undefined then noop\n        } else if (newValue != null) {\n          // if newValue is a computed set the computed directly instead of wrapping in signal\n          if (hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch(path, '')\n          } else {\n            deepObj[prop] = signal(deep(newValue, `${path}.`))\n            dispatch(path, newValue)\n          }\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      deleteProperty(_, prop: string) {\n        delete deepObj[prop]\n        keys(keys() + 1)\n        return true\n      },\n      ownKeys() {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (path?: string, value?: any) => {\n  if (path !== undefined && value !== undefined) {\n    currentPatch.push([path, value])\n  }\n  if (!batchDepth && currentPatch.length) {\n    const detail = pathToObj(currentPatch)\n    currentPatch.length = 0\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail,\n      }),\n    )\n  }\n}\n\nexport const mergePatch = (\n  patch: JSONPatch,\n  { ifMissing }: MergePatchArgs = {},\n): void => {\n  beginBatch()\n  for (const key in patch) {\n    if (patch[key] == null) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nexport const mergePaths = (paths: Paths, options?: MergePatchArgs): void =>\n  mergePatch(pathToObj(paths), options)\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] == null) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nconst toRegExp = (val: string | RegExp): RegExp =>\n  typeof val === 'string' ? RegExp(val.replace(/^\\/|\\/$/g, '')) : val\n\n/**\n * Filters the root store based on an include and exclude RegExp\n *\n * @returns The filtered object\n */\nexport const filtered = (\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n): Record<string, any> => {\n  const includeRe = toRegExp(include)\n  const excludeRe = toRegExp(exclude)\n  const paths: Paths = []\n  const stack: [any, string][] = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      const path = prefix + key\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${path}.`])\n      } else if (includeRe.test(path) && !excludeRe.test(path)) {\n        paths.push([path, getPath(path)])\n      }\n    }\n  }\n\n  return pathToObj(paths)\n}\n\nexport const root: Record<string, any> = deep({})\n", "import type { HTMLOrSVG } from '@engine/types'\n\nexport const isHTMLOrSVG = (el: Node): el is HTMLOrSVG =>\n  el instanceof HTMLElement ||\n  el instanceof SVGElement ||\n  el instanceof MathMLElement\n", "import type { Modifiers } from '@engine/types'\n\nexport const kebab = (str: string): string =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .replace(/[\\s_]+/g, '-') // Replace whitespace and underscores with hyphens\n    .toLowerCase()\n\nexport const camel = (str: string): string =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string): string => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string): string =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const title = (str: string): string =>\n  str.replace(/\\b\\w/g, (char) => char.toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = {\n  camel: (str) => str.replace(/-[a-z]/g, (x) => x[1].toUpperCase()),\n  snake: (str) => str.replace(/-/g, '_'),\n  pascal: (str) => str[0].toUpperCase() + caseFns.camel(str.slice(1)),\n}\n\nexport const modifyCasing = (\n  str: string,\n  mods: Modifiers,\n  defaultCase = 'camel',\n): string => {\n  for (const c of mods.get('case') || [defaultCase]) {\n    str = caseFns[c]?.(str) || str\n  }\n  return str\n}\n\nexport const aliasify = (name: string) =>\n  ALIAS ? `data-${ALIAS}-${name}` : `data-${name}`\n", "import { DATASTAR_FETCH_EVENT, DSP, DSS } from '@engine/consts'\nimport { root } from '@engine/signals'\nimport type {\n  ActionContext,\n  ActionPlugin,\n  AttributeContext,\n  AttributePlugin,\n  DatastarFetchEvent,\n  HTMLOrSVG,\n  Modifiers,\n  Requirement,\n  WatcherPlugin,\n} from '@engine/types'\nimport { isHTMLOrSVG } from '@utils/dom'\nimport { aliasify, snake } from '@utils/text'\n\nconst url = 'https://data-star.dev/errors'\n\nconst error = (\n  ctx: Record<string, any>,\n  reason: string,\n  metadata: Record<string, any> = {},\n) => {\n  Object.assign(metadata, ctx)\n  const e = new Error()\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nconst actionPlugins: Map<string, ActionPlugin> = new Map()\nconst attributePlugins: Map<string, AttributePlugin> = new Map()\nconst watcherPlugins: Map<string, WatcherPlugin> = new Map()\n\nexport const actions: Record<\n  string,\n  (ctx: ActionContext, ...args: any[]) => any\n> = new Proxy(\n  {},\n  {\n    get: (_, prop: string) => actionPlugins.get(prop)?.apply,\n    has: (_, prop: string) => actionPlugins.has(prop),\n    ownKeys: () => Reflect.ownKeys(actionPlugins),\n    set: () => false,\n    deleteProperty: () => false,\n  },\n)\n\n// Map of cleanups keyed by element, attribute name, and cleanup name\nconst removals = new Map<HTMLOrSVG, Map<string, Map<string, () => void>>>()\n\nconst queuedAttributes: AttributePlugin[] = []\nconst queuedAttributeNames = new Set<string>()\nconst observedRoots = new WeakSet<Node>()\nexport const attribute = <R extends Requirement, B extends boolean>(\n  plugin: AttributePlugin<R, B>,\n): void => {\n  queuedAttributes.push(plugin as unknown as AttributePlugin)\n\n  if (queuedAttributes.length === 1) {\n    setTimeout(() => {\n      for (const attribute of queuedAttributes) {\n        queuedAttributeNames.add(attribute.name)\n        attributePlugins.set(attribute.name, attribute)\n      }\n      queuedAttributes.length = 0\n      apply()\n      queuedAttributeNames.clear()\n    })\n  }\n}\n\nexport const action = <T>(plugin: ActionPlugin<T>): void => {\n  actionPlugins.set(plugin.name, plugin)\n}\n\ndocument.addEventListener(DATASTAR_FETCH_EVENT, ((\n  evt: CustomEvent<DatastarFetchEvent>,\n) => {\n  const plugin = watcherPlugins.get(evt.detail.type)\n  if (plugin) {\n    plugin.apply(\n      {\n        error: error.bind(0, {\n          plugin: { type: 'watcher', name: plugin.name },\n          element: {\n            id: (evt.target as Element).id,\n            tag: (evt.target as Element).tagName,\n          },\n        }),\n      },\n      evt.detail.argsRaw,\n    )\n  }\n}) as EventListener)\n\nexport const watcher = (plugin: WatcherPlugin): void => {\n  watcherPlugins.set(plugin.name, plugin)\n}\n\nconst cleanupEls = (els: Iterable<HTMLOrSVG>): void => {\n  for (const el of els) {\n    const elCleanups = removals.get(el)\n    if (elCleanups && removals.delete(el)) {\n      for (const attrCleanups of elCleanups.values()) {\n        for (const cleanup of attrCleanups.values()) {\n          cleanup()\n        }\n      }\n    }\n  }\n}\n\nconst aliasedIgnore = aliasify('ignore')\nconst aliasedIgnoreAttr = `[${aliasedIgnore}]`\nconst shouldIgnore = (el: HTMLOrSVG) =>\n  el.hasAttribute(`${aliasedIgnore}__self`) || !!el.closest(aliasedIgnoreAttr)\n\nconst applyEls = (els: Iterable<HTMLOrSVG>, onlyNew?: boolean): void => {\n  for (const el of els) {\n    if (!shouldIgnore(el)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(\n          el,\n          key.replace(/[A-Z]/g, '-$&').toLowerCase(),\n          el.dataset[key]!,\n          onlyNew,\n        )\n      }\n    }\n  }\n}\n\nconst observe = (mutations: MutationRecord[]) => {\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          cleanupEls([node])\n          cleanupEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (\n      type === 'attributes' &&\n      attributeName!.startsWith('data-') &&\n      isHTMLOrSVG(target) &&\n      !shouldIgnore(target)\n    ) {\n      // skip over 'data-'\n      const key = attributeName!.slice(5)\n      const value = target.getAttribute(attributeName!)\n      if (value === null) {\n        const elCleanups = removals.get(target)\n        if (elCleanups) {\n          const attrCleanups = elCleanups.get(key)\n          if (attrCleanups) {\n            for (const cleanup of attrCleanups.values()) {\n              cleanup()\n            }\n            elCleanups.delete(key)\n          }\n        }\n      } else {\n        applyAttributePlugin(target, key, value)\n      }\n    }\n  }\n}\n\n// TODO: mutation observer per root so applying to web component doesnt overwrite main observer\nconst mutationObserver = new MutationObserver(observe)\n\nexport const parseAttributeKey = (\n  rawKey: string,\n): {\n  pluginName: string\n  key: string | undefined\n  mods: Modifiers\n} => {\n  const [namePart, ...rawModifiers] = rawKey.split('__')\n  const [pluginName, key] = namePart.split(/:(.+)/)\n  const mods: Modifiers = new Map()\n\n  for (const rawMod of rawModifiers) {\n    const [label, ...mod] = rawMod.split('.')\n    mods.set(label, new Set(mod))\n  }\n\n  return { pluginName, key, mods }\n}\n\nexport const isDocumentObserverActive = () =>\n  observedRoots.has(document.documentElement)\n\nexport const apply = (\n  root: HTMLOrSVG | ShadowRoot = document.documentElement,\n  observeRoot = true,\n): void => {\n  if (isHTMLOrSVG(root)) {\n    applyEls([root], true)\n  }\n  applyEls(root.querySelectorAll<HTMLOrSVG>('*'), true)\n\n  if (observeRoot) {\n    mutationObserver.observe(root, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n    })\n    observedRoots.add(root)\n  }\n}\n\nconst applyAttributePlugin = (\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n  onlyNew?: boolean,\n): void => {\n  if (!ALIAS || attrKey.startsWith(`${ALIAS}-`)) {\n    const rawKey = ALIAS ? attrKey.slice(ALIAS.length + 1) : attrKey\n    const { pluginName, key, mods } = parseAttributeKey(rawKey)\n    const plugin = attributePlugins.get(pluginName)\n    if ((!onlyNew || queuedAttributeNames.has(pluginName)) && plugin) {\n      const ctx = {\n        el,\n        rawKey,\n        mods,\n        error: error.bind(0, {\n          plugin: { type: 'attribute', name: plugin.name },\n          element: { id: el.id, tag: el.tagName },\n          expression: { rawKey, key, value },\n        }),\n        key,\n        value,\n        loadedPluginNames: {\n          actions: new Set(actionPlugins.keys()),\n          attributes: new Set(attributePlugins.keys()),\n        },\n        rx: undefined,\n      } as AttributeContext\n\n      const keyReq =\n        (plugin.requirement &&\n          (typeof plugin.requirement === 'string'\n            ? plugin.requirement\n            : plugin.requirement.key)) ||\n        'allowed'\n      const valueReq =\n        (plugin.requirement &&\n          (typeof plugin.requirement === 'string'\n            ? plugin.requirement\n            : plugin.requirement.value)) ||\n        'allowed'\n\n      const keyProvided = key !== undefined && key !== null && key !== ''\n      const valueProvided =\n        value !== undefined && value !== null && value !== ''\n\n      if (keyProvided) {\n        if (keyReq === 'denied') {\n          throw ctx.error('KeyNotAllowed')\n        }\n      } else if (keyReq === 'must') {\n        throw ctx.error('KeyRequired')\n      }\n\n      if (valueProvided) {\n        if (valueReq === 'denied') {\n          throw ctx.error('ValueNotAllowed')\n        }\n      } else if (valueReq === 'must') {\n        throw ctx.error('ValueRequired')\n      }\n\n      if (keyReq === 'exclusive' || valueReq === 'exclusive') {\n        if (keyProvided && valueProvided) {\n          throw ctx.error('KeyAndValueProvided')\n        }\n        if (!keyProvided && !valueProvided) {\n          throw ctx.error('KeyOrValueRequired')\n        }\n      }\n\n      const cleanups = new Map<string, () => void>()\n      if (valueProvided) {\n        let cachedRx: GenRxFn\n        ctx.rx = (...args: any[]) => {\n          if (!cachedRx) {\n            cachedRx = genRx(value, {\n              returnsValue: plugin.returnsValue,\n              argNames: plugin.argNames,\n              cleanups,\n            })\n          }\n          return cachedRx(el, ...args)\n        }\n      }\n\n      const cleanup = plugin.apply(ctx)\n      if (cleanup) {\n        cleanups.set('attribute', cleanup)\n      }\n\n      let elCleanups = removals.get(el)\n      if (elCleanups) {\n        const attrCleanups = elCleanups.get(rawKey)\n        if (attrCleanups) {\n          for (const oldCleanup of attrCleanups.values()) {\n            oldCleanup()\n          }\n        }\n      } else {\n        elCleanups = new Map()\n        removals.set(el, elCleanups)\n      }\n      elCleanups.set(rawKey, cleanups)\n    }\n  }\n}\n\ntype GenRxOptions = {\n  returnsValue?: boolean\n  argNames?: string[]\n  cleanups?: Map<string, () => void>\n}\n\ntype GenRxFn = <T>(el: HTMLOrSVG, ...args: any[]) => T\n\nconst genRx = (\n  value: string,\n  {\n    returnsValue = false,\n    argNames = [],\n    cleanups = new Map(),\n  }: GenRxOptions = {},\n): GenRxFn => {\n  let expr = ''\n  if (returnsValue) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = value.trim()\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  let counter = 0\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `__escaped${counter++}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  // Replace signal references with bracket notation\n  // Examples:\n  //   $count          -> $['count']\n  //   $count--        -> $['count']--\n  //   $foo.bar        -> $['foo']['bar']\n  //   $foo-bar        -> $['foo-bar']\n  //   $foo.bar-baz    -> $['foo']['bar-baz']\n  //   $foo-$bar       -> $['foo']-$['bar']\n  //   $arr[$index]    -> $['arr'][$['index']]\n  //   $['foo']        -> $['foo']\n  //   $foo[obj.bar]   -> $['foo'][obj.bar]\n  //   $foo['bar.baz'] -> $['foo']['bar.baz']\n  //   $123            -> $['123']\n  //   $foo.0.name     -> $['foo']['0']['name']\n\n  expr = expr\n    // $['x'] -> $x (normalize existing bracket notation)\n    .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, '$$$1')\n    // $x -> $['x'] (including dots and hyphens)\n    .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) =>\n      signalName\n        .split('.')\n        .reduce((acc: string, part: string) => `${acc}['${part}']`, '$'),\n    )\n\n  expr = expr.replaceAll(/@([A-Za-z_$][\\w$]*)\\(/g, '__action(\"$1\",evt,')\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  try {\n    const fn = Function('el', '$', '__action', 'evt', ...argNames, expr)\n    return (el: HTMLOrSVG, ...args: any[]) => {\n      const action = (name: string, evt: Event | undefined, ...args: any[]) => {\n        const err = error.bind(0, {\n          plugin: { type: 'action', name },\n          element: { id: el.id, tag: el.tagName },\n          expression: {\n            fnContent: expr,\n            value,\n          },\n        })\n        const fn = actions[name]\n        if (fn) {\n          return fn(\n            {\n              el,\n              evt,\n              error: err,\n              cleanups,\n            },\n            ...args,\n          )\n        }\n        throw err('UndefinedAction')\n      }\n      try {\n        return fn(el, root, action, undefined, ...args)\n      } catch (e: any) {\n        console.error(e)\n        throw error(\n          {\n            element: { id: el.id, tag: el.tagName },\n            expression: {\n              fnContent: expr,\n              value,\n            },\n            error: e.message,\n          },\n          'ExecuteExpression',\n        )\n      }\n    }\n  } catch (e: any) {\n    console.error(e)\n    throw error(\n      {\n        expression: {\n          fnContent: expr,\n          value,\n        },\n        error: e.message,\n      },\n      'GenerateExpression',\n    )\n  }\n}\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR_FETCH_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "hasOwn", "isPojo", "obj", "pathToObj", "paths", "result", "path", "value", "keys", "lastKey", "obj", "acc", "key", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "prevSub", "activeSub", "version", "beginBatch", "endBatch", "flush", "dispatch", "startPeeking", "sub", "stopPeeking", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "effectOper", "run", "update", "updateComputed", "updateSignal", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "propagate", "currentValue", "shallowPropagate", "unlink", "prevDep", "depsTail_", "nextDep", "version_", "subsTail_", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "isValidLink", "subSubs", "nextSub", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "checkLink", "getPath", "path", "result", "root", "split", "hasOwn", "deep", "prefix", "isArr", "isPojo", "deepObj", "key", "keys", "_", "prop", "newValue", "diff", "patch", "i", "pathStr", "nextVal", "detail", "pathToObj", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "ifMissing", "mergeInner", "mergePaths", "paths", "options", "target", "targetParent", "toRegExp", "val", "filtered", "include", "exclude", "obj", "includeRe", "excludeRe", "node", "isHTMLOrSVG", "el", "kebab", "str", "snake", "str", "kebab", "aliasify", "name", "url", "error", "ctx", "reason", "metadata", "e", "r", "snake", "q", "c", "actionPlugins", "attributePlugins", "watcherPlugins", "actions", "_", "prop", "removals", "queuedAttributes", "queuedAttributeNames", "observedRoots", "attribute", "plugin", "apply", "action", "DATASTAR_FETCH_EVENT", "evt", "watcher", "cleanupEls", "els", "el", "elCleanups", "attrCleanups", "cleanup", "aliasedIgnore", "aliasify", "aliasedIgnoreAttr", "shouldIgnore", "applyEls", "onlyNew", "key", "applyAttributePlugin", "observe", "mutations", "target", "type", "attributeName", "addedNodes", "removedNodes", "node", "isHTMLOrSVG", "value", "mutationObserver", "parseAttributeKey", "rawKey", "namePart", "rawModifiers", "pluginName", "mods", "rawMod", "label", "mod", "apply", "root", "observeRoot", "isHTMLOrSVG", "applyEls", "mutationObserver", "observedRoots", "applyAttributePlugin", "el", "attrKey", "value", "onlyNew", "rawKey", "pluginName", "key", "mods", "parseAttributeKey", "plugin", "attributePlugins", "queuedAttributeNames", "ctx", "error", "actionPlugins", "keyReq", "valueReq", "keyProvided", "valueProvided", "cleanups", "cachedRx", "args", "genRx", "cleanup", "elCleanups", "removals", "attrCleanups", "oldCleanup", "returnsValue", "argNames", "expr", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSP", "DSS", "counter", "match", "k", "v", "_", "signalName", "acc", "part", "fn", "action", "name", "evt", "err", "actions", "e"]
}
